# Exercises and algorithms from the Book

#|File|Problem/Algorithm/Description
-----|--------------|---------------------------------------------------------------------------------------
-|template.py|Template for python programs
1|smac.py|Useful functions: BoxMuller, CircleThrowing, and SphereGenerator
1.1|direct-plot.py|Implement Algorithm 1.1. Plot error and investigate relationship with N.
-|markov-pi.py|Implement Algorithm 1.2. Plot error and rejection rate.
-|direct.py|1.3 Store state in file
-|smacfiletoken.py|
-|markov-discrete-pebble.py| 1.4 Use table
-|large-markov.py|
-|transfer.m|1.8 Eigenvalues of transfer matrix
-|direct-needle.py|Exercise 1.6: implement Alg 1.4 direct needle and Alg 1.5 direct-needle(patch)
1.2|permutation.py|1.9 Sample permutations using Alg. 1.11 and verify that it generate all 120 permutations of 5 elements equally often
-|permutation-histogram.py
-|naivegauss.py|1.12 Gauss
-|direct-surface.py|Monte Carlo simulation of Exercise 2.11 of Chaosbook: in higher dimensions, any two vectors are nearly orthogonal
-|ran-perm.py|Exercise 1.9 (a) Sample permutations using algoritm 1.11 and check that this algorithm generates all 120 permutations of 5 elements equally often.  (b) Determine the cycle representation of each permutation that is generated.
-|ran-perm-alt.py|Exercise 1.9 (c) Alternative algorithm
-|exercise_1_12.py|Exercise 1.12. Implement both naive Algorithm 1.17 (naive Gauss) and 1.18 (Box Muller). For what value of K can you still detect statistially significant differences between the two algorithms?
-|exercise_1_12a.py|Exercise 1.12 - plot results of KS test.
-|exercise_1_14.py|Exercise 1.14. Sample random vectors on the surface of a sphere using Algorithm 1.22 and plot x[0]**2 + y[0]**2
-|exercise_1_16.py|Exercise 1.16. Compare sampling efficiencies of Algoritms 1.13 and 1.14
1.3|binomialconvolution.py|1.18 Binomial Convolution
1.4.2|direct-gamma.py|1.22 Importance sampling:Implement Algorithm 1.29, subtract mean value for each sample, and generate histograms of the average of N samples  and the rescaled averages.
-|direct-gamma-zeta.py|1.21 Implement Algorithm 1.31
-|markov-zeta.py|Algorithm 1.31, use of Markov Chain to detect non-integrable singularity.
1.4.4|levy-convolution.py|Algorithm 1.32
2.1.4|spheres2.py|Exercise 2-4: Sinai's system of two large sphere in a box. Show histogram of positions.
2.2.1|pair-time.py|Algorithm 2.2: Pair collision time for two particles
-|md.py|Algorithm 2.3 Pair collision
-|md-viz.py|Visualize data generated by md.py
-|md-plot.py|Visualize output from md.cpp. Plot distribution of distances from wall, and compare energy histogram with Bolzmann distribution.
-|md|Algorithm 2.3 Pair collision
-|direct-disks.py|Exercise 2.6: directly sample the positions of 4 disks in a square box without periodic boundary conditions, for different covering densities
-|hist-plot.py|Exercise 2.6:  ...
-|geometry.py|Used to implement periodic and aperiodic boundary conditions in Exercises 2.6-2.8
2.2.2|directDisksAny.py|
2.2.3|markov-disks.py|Exercise 2.8 and Algorithm 2.9. Generating a hard disk configuration from an earlier valid configuration using MCMC.
3.1|harmonic_wavefunction.py|Exercise 3.1: verify orthonormality of the solutions to Schroedinger's equation for Simple Harmonic Oscillator
-|harmonic_density.py|Exercise 3.2: determine density matrix
3.2|matrix-square.py|Exercise 3.4: implement Alg 3.3, matrix-square
-|matrix-square-check.py|Exercise 3.4: check results of matrix squaring against exact solution.
-|poeschl-teller.py|Exercise 3.5: plot Poeschl-Teller potential and investigate density matrix and partition function
3.3||The Feynman path integral
3.4||Pair density matrices
3.5||Geometry of Paths
4|| Bosons
5.1|energy_ising.py|5.1: Compute energy of a simple Ising configuration
-|edge_ising.py|Algorithm 5.5 edge-ising. Gray code enumeration of the loop configurations in Figure 5.8
-|enumerate_ising.py|Algorithm 5.3: single flip enumeration for the Ising model.
-|Exercise 5-2. Generate configurations from binary representation (incomplete)
-|Exercise 5-4: Implement thermo-ising for mean energ and cV
-|Exercise 5-6.Plot magnetization as a function of temperature
-|exercise_5.7.py|Exercise 5.7. Compute Partition function using loop configurations as described in 5.1.3
-|ising.py|Shared code for Ising model: Algorithm 5.2, Gray code for spins; generate neighbours of a spin; calculate energy for a configuration.
-|ising_enum.py|Algorithm 5.3: Single spin-slip enumeration for Ising model
-|ising-stats.py|Figure 6.6 - plot data from ising.py
-|ising|C++ implementations of Algorithm 5.3 (single flip enumeration for the Ising model) and 5.7 (MCMC)
5.2|cluster_ising.py|Algorithm 5-9: cluster ising
-|exercise_5_10a.py|Exercise 5.10: Implement Local Metropolis algorithm and test it against the specific heat capacity.
-|exercise_5_10b.py|Exercise 5.10: Plot M against T
-|exercise_5_11.py|Exercise 5-11/Algorithm 5-9: cluster ising
-|ising_db.py|Exercise 5-11: a library to facilite reuseing data from previous runs
-|thermo_ising.py|Exercise 5-11: calculate thermodynamic quantities
-|thermo_db.py|Exercise 5-11: calculate thermodynamic quantities from database
-|markov_ising.py|Algorithm 5.7: Local Metropolis algorithm for the Ising model
-|thermo.py|Exercise 5-11: calculate thermodynamic quantities
-|bench42.sh|Benchmark effect of [Issue #42](https://github.com/weka511/smac/issues/42)
-|cpp_mcmc.py|Script to plot C++ MCMC outpu
5.3||Generalized Ising models
6||Entropic Forces
7||Dynamic Monte Carlo Methods
